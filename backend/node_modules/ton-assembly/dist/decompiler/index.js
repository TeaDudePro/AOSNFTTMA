"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || (function () {
    var ownKeys = function(o) {
        ownKeys = Object.getOwnPropertyNames || function (o) {
            var ar = [];
            for (var k in o) if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;
            return ar;
        };
        return ownKeys(o);
    };
    return function (mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== "default") __createBinding(result, mod, k[i]);
        __setModuleDefault(result, mod);
        return result;
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
const core_1 = require("@ton/core");
const runtime_1 = require("../runtime");
const text_1 = require("../text");
const fs = __importStar(require("node:fs"));
const walker_util_1 = require("../runtime/walker-util");
const methodName = (id) => {
    if (id === 0)
        return "recv_internal";
    if (id === -1)
        return "recv_external";
    return `get_${id}`;
};
const indent = (str) => {
    return str
        .trim()
        .split("\n")
        .map(line => "    " + line)
        .join("\n");
};
const main = async () => {
    const hex = "b5ee9c7241021401000316000114ff00f4a413f4bcf2c80b010201200210020148030704fcd020d72c239b4b73a48f6e21d749810280be915be1218308d722028308d723ed44d0d200d31f20d31fd3fff40506f9014088f910925f06e1036e12b1f2e08402d31fd31fd31ff404d2005137baf2e0855047baf2e08601f823bcf2e08803a4c8cf83cb1f12cec9ed5470216e9131e30e028e8301db3c915be2e03189d7270412050600687022d739308e2220d74bc002f2e093c028f2e093d72c20761e436cf2e093d74cd7393001a421c70012e6308407bbf2e09301ed5500086578746e01e48eeef892fa44f828fa443058bd915be0ed44d0810141d721f4058307f40e6fa1319130e1d33f31f404d2007f236e91338e347024d739308e2220d74bc002f2e093c028f2e093d72c20761e436cf2e093d74cd7393001a421c70012e6308407bbf2e09303ed55e2018e8301db3c915be2e03012020120080f020120090c02016e0a0b0017adce76a26869a018eb85ffc00017af1df6a268699018eb858fc00201480d0e0017b325fb513434c00c75c2c7e00011b262fb513435c280200019be5f0f6a2684080a0eb90fa02c02dcf2208308d722018308d72320d72c239b4b3b74f2e08ad31fd31fd31ff404d200ed44d0d200d31f20d31fd3fff4050cf90140ddf910f2e087096e12b1f2e0845144baf2e0855057baf2e08602f823bcf2e088f800a4c8cf83cb1f13cec9ed54f80f70226e9132e30e8e82db3ce05b111200767023d739308e2920d74bc002f2e093c028f2e093d72c20761e436cf2e093d4d70b0772b0f2e089d7393001a421c70012e6308407bbf2e09302ed550190eda2edfbeb21d72c08148e2dfa4030fa44f828fa443058baf2e091ed44d0810141d718f40583078b0c034444f436f2e08b01c8cef400c9ed548ae221d74a935bdb31e101d74cd0011300ecd72c081c8e36fa4030fa44f828fa443058baf2e091ed44d0d200810140d718f405138307f45bf2e08c2195206ef2d090df01c8ca0012cef400c9ed548e37d72c082493f2c08de121f2e092ed44d001d70a0001d20020810140d721f4055123bdf2e08f22913195016ef2d08ee201c8ca00cec9ed54e291b3afb1";
    const code = core_1.Cell.fromHex(hex);
    console.log(code);
    const instructions = (0, runtime_1.decompileCell)(code);
    console.log(instructions);
    const inlinedFunctions = new Map();
    for (const instr of instructions) {
        (0, walker_util_1.walk)(instr, (instr, arg, _argName, _argIndex) => {
            if (instr.$ === "CALLREF") {
                inlinedFunctions.set((0, text_1.print)(instr.arg0.instructions), instr);
                const arg = instr.arg0;
                if (arg.$ === "Instructions") {
                    // Object.assign(instr, {
                    //     $: "CALLDICT",
                    //     arg0: inlinedFunctions.size,
                    //     loc: undefined,
                    // } satisfies CALLDICT)
                }
            }
            if (arg.$ === "code") {
                // console.log(`find code arg of ${instr.$}`)
            }
        });
    }
    const lines = [];
    for (const [index, entry] of [...inlinedFunctions.values()].entries()) {
        lines.push(`@inline_ref\nfun inlined_${index}() {`);
        const instructions = entry.arg0;
        lines.push(indent((0, text_1.print)(instructions.instructions)), `}\n`);
    }
    const dictpush = instructions[1];
    const dict = dictpush.arg1;
    for (const method of dict.methods.sort((a, b) => a.id - b.id)) {
        const name = methodName(method.id);
        const args = method.id === -1 ? "in_msg: slice" : "";
        lines.push(`fun ${name}(${args}) {`, indent((0, text_1.print)(method.instructions)), `}\n`);
    }
    console.log(lines.join("\n"));
    fs.writeFileSync("out.dec", lines.join("\n"));
};
void main();
//# sourceMappingURL=index.js.map