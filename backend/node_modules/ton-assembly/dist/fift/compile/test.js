"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const parse_1 = require("../parse/parse");
const text_1 = require("../../text");
const runtime_1 = require("../../runtime");
const node_child_process_1 = require("node:child_process");
const node_fs_1 = require("node:fs");
const core_1 = require("@ton/core");
const diff_1 = require("diff");
const compile_1 = require("./compile");
function compileFift(code) {
    if ((0, node_fs_1.existsSync)("out.boc")) {
        (0, node_fs_1.rmSync)("out.boc");
    }
    (0, node_fs_1.writeFileSync)("1.fif", code + '\n\nboc>B "out.boc" B>file');
    (0, node_child_process_1.execSync)("/Users/petrmakhnev/ton-tolk/cmake-build-debug/crypto/fift -I /Users/petrmakhnev/ton-tolk/crypto/fift/lib 1.fif");
    return core_1.Cell.fromBoc((0, node_fs_1.readFileSync)("out.boc"))[0] ?? new core_1.Cell();
}
// eslint-disable-next-line @typescript-eslint/require-await
const main = async () => {
    const _ = `
    "Asm.fif" include
    // automatically generated from 1.tolk
    PROGRAM{
      DECLGLOBVAR $foo
      DECLGLOBVAR $bar
      0 DECLMETHOD onInternalMessage()
      DECLPROC foo()
      foo() PROC:<{
        ADD 
      }>
      onInternalMessage() PROC:<{
        11 PUSHINT
        0 THROWIF
        x{1} SDBEGINSQ
        IFJMP:<{
          256 PLDI
          THROWANY
        }>
        x{2} SDBEGINSQ
        IFJMP:<{
          256 LDSLICE
          DROP
          HASHSU
          THROWANY
        }>
        foo() CALLDICT
        $bar SETGLOB
        3 THROW
      }>
    }END>c
    `;
    const code = (0, node_fs_1.readFileSync)("wallet_v5.now.fif", "utf8");
    const result = (0, parse_1.parse)("test.fift", code);
    if (result.$ === "ParseFailure") {
        throw result.error;
    }
    const ctx = (0, compile_1.processAst)(result.ast);
    const methods = result.ast.program.definitions.map(def => {
        const definition = (0, compile_1.compileDefinition)(def, ctx);
        ctx.compiledFunctions.set(def.def.name.name, definition);
        return definition.compiled;
    });
    const usedMethods = methods.filter(method => {
        const func = ctx.functions.entries().find(([, id]) => method.id === id);
        if (!func)
            return true;
        const [name] = func;
        const usageCount = ctx.usedFunctions.get(name) ?? 0;
        return usageCount > 0;
    });
    const mainDictionary = {
        $: "DecompiledDict",
        methods: usedMethods,
    };
    const toplevel = [
        (0, runtime_1.SETCP)(0),
        (0, runtime_1.DICTPUSHCONST)(19, mainDictionary),
        (0, runtime_1.DICTIGETJMPZ)(),
        (0, runtime_1.THROWARG)(11),
    ];
    console.log("Raw compiled fift:");
    console.log((0, text_1.print)(toplevel));
    const cell = (0, runtime_1.compileCell)(toplevel);
    const text = (0, text_1.print)((0, runtime_1.decompileCell)(cell));
    console.log("TASM:\n\n", text);
    (0, node_fs_1.writeFileSync)("out.tasm.compiled", text);
    const fiftCell = compileFift(code);
    console.log(fiftCell.toBoc().toString("hex"));
    const fiftText = (0, text_1.print)((0, runtime_1.decompileCell)(fiftCell));
    console.log("Fift:\n\n", fiftText);
    (0, node_fs_1.writeFileSync)("out.fif.compiled", fiftText);
    if (cell.toString() !== fiftCell.toString()) {
        console.log((0, diff_1.diffLines)(cell.toString(), fiftCell.toString()));
        console.log((0, diff_1.diffLines)(text, fiftText));
        throw new Error("Mismatch with Fift");
    }
    console.log("Compilation succeed");
};
void main();
//# sourceMappingURL=test.js.map